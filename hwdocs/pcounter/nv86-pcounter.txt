= NV86 Graphics Counters =

1. The SETUP signals
1.1 setup_primitive_count
1.2 setup_point_count
1.3 setup_line_count
1.4 setup_triangle_count
1.5 setup_primitive_culled_count
2. The IA signals
2.1 input_assembler_busy
2.2 input_assembler_waits_for_fb
3. The VS signals
3.1 vertex_shader_busy
3.2 vertex_shader_instruction_rate

== The PRIMITIVE signals ==

These signals are always on set 1.

signal                          |86| test
--------------------------------+-+-------------------------------------
NV_setup_primitive_count        |d2| tests/test_setup_primitive_count.c
NV_setup_point_count            |d3| tests/test_setup_point_count.c
NV_setup_line_count             |d4| tests/test_setup_line_count.c
NV_setup_triangle_count         |d5| tests/test_setup_triangle_count.c
NV_setup_primitive_culled_count |??| ??

=== setup_primitive_count ===

Returns the number of primitives processed in the geometry subsystem. This
experiments counts points, lines and triangles. To count only triangles,
use the setup_triangle_count counter. Balance these counts with the number
of pixels being drawn to see if you could simplify your geometry and use
bump/displacement maps, for example.

=== setup_point_count ===

The number of points seen by the primitive setup unit (just before
rasterization).

=== setup_line_count ===

The number of lines seen by the primitive setup unit (just before
rasterization).

=== setup_triangle_count ===

Returns the number of triangles processed in the geometry subsystem.

=== setup_primitive_culled_count ===

Returns the number of primitives culled in primitive setup. If you are
performing viewport culling, this gives you an indication of the accuracy
of the algorithm being used, and can give you and idea if you need to improves
this culling. This includes primitives culled when using backface culling.
Drawing a fully visible sphere on the screen should cull half of the triangles
if backface culling is tuerned on and all the triangles are ordered
consistently (CW or CCW).

== The IA signals ==

These signals are always on set 1 and currently only work on the Linux blob.

signal                          |EVENT_SRC|EVENT_OP
--------------------------------+---------+-----------------------------
NV_input_assembler_busy         |68697d7e |f888
NV_input_assembler_waits_for_fb |74       |aaaa

TOOO: Find out why it doesn't work on Nouveau, we probably miss a mux somewhere.

=== input_assembler_busy ===

The % of time the input assembler unit is busy. This is mainly impacted by both
the number of vertices processed as well as the size of the attributes on those
vertices. You can optimize this by reducing vertex size as much as possible and
using indexed primitives to take advantage of the vertex cache.

=== input_assembler_waits_for_fb ===

This is the amount of time the input assembler unit was waiting for data from
the frame buffer unit.

== The VS signals ==

These signals are always on set 3.

[XXX: write me]

=== vertex_shader_busy ===

This is the % of time that shader unit 0 was busy scaled by the ratio of vertex
shader instructions to all shader type instructions
(or vertex_shader_instruction_rate). If this value is high but, for instance,
pixel_shader_busy is slow, it is an indication that you may be verte/geometry
bound. This can be from geometry that is too detailed or even from vertex
programs that are overly complex and need to be simplified. In addition, taking
advantage of the post T&L cache (by reducing vertex size and using indexed
primitives) can prevent processing the same vertices multiple times.

=== vertex_shader_instruction_rate ===

The % of all shader instructions seen on the first SM unit that were executing
vertex shaders.
